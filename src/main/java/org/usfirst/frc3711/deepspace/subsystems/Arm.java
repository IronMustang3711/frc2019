// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3711.deepspace.subsystems;


import com.ctre.phoenix.motorcontrol.*;
import com.ctre.phoenix.motorcontrol.can.TalonSRXConfiguration;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.InstantCommand;
import edu.wpi.first.wpilibj.shuffleboard.BuiltInWidgets;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import org.usfirst.frc3711.deepspace.TalonID;
import org.usfirst.frc3711.deepspace.talon.SlotConfigBuilder;
import org.usfirst.frc3711.deepspace.talon.TalonConfigBuilder;
import org.usfirst.frc3711.deepspace.talon.TalonUtil;

import java.util.Map;


/**
 *
 */
public class Arm extends TalonSubsystem {

  private static final
  TalonSRXConfiguration DEFAULT_CONFIG
      = TalonConfigBuilder.newBuilder()
                          .withSlot(
                              SlotConfigBuilder.newBuilder()
                                               .withSlot(1)
                                               .withKP(2.0)
                                               .build())
                          .withSlot(
                              SlotConfigBuilder.newBuilder()
                                               .withSlot(0)
                                               .withKP(2.5)
                                               .withKF(10.0)
                                               .build())


                          .withForwardSoftLimitThreshold(3500)
                          .withReverseSoftLimitThreshold(-100)
                          .withForwardSoftLimitEnable(true)
                          .withReverseSoftLimitEnable(true)

                          .withMotionCruiseVelocity(80)
                          .withMotionAcceleration(50)

                          .withPeakOutputForward(1.0)
                          .withPeakOutputReverse(-0.6)

                          .withNominalOutputForward(0.0)
                          .withNominalOutputReverse(0.0)

                          .withVoltageCompSaturation(10.0)

                          .withPeakCurrentLimit(25)
                          .withPeakCurrentDuration(2000)
                          .withContinuousCurrentLimit(1)

                          .withForwardLimitSwitchSource(LimitSwitchSource.Deactivated)
                          .withReverseLimitSwitchSource(LimitSwitchSource.Deactivated)
                          .withForwardLimitSwitchNormal(LimitSwitchNormal.Disabled)
                          .withReverseLimitSwitchNormal(LimitSwitchNormal.Disabled)

                          .withOpenloopRamp(1.0)
                          .build();


  private final Runnable talonTelemetry;

  private final SendableChooser<ControlMode> modeChooser;
  private final NetworkTableEntry percentOutput;
  private final NetworkTableEntry lowPowerMode;

  private long lowPowerStartTime;

  public Arm() {
    super(Arm.class.getSimpleName(), TalonID.ARM.getId());
    talonTelemetry = TalonUtil.motionMagicTelemetry(this);
    modeChooser = new SendableChooser<>();
    addChild("mode chooser", modeChooser);
    modeChooser.setDefaultOption("MotionMagic", ControlMode.MotionMagic);
    modeChooser.addOption("Position", ControlMode.Position);

    tab.add(modeChooser);

    tab.add(this);

    percentOutput = tab.add("output%", 0.0)
                        .withWidget(BuiltInWidgets.kNumberSlider)
                        .withProperties(Map.of("min", -4, "max", 0.4))
                        .getEntry();

    lowPowerMode = tab.add("low power mode", false)
                       .withWidget(BuiltInWidgets.kBooleanBox)
                       .getEntry();

    tab.add(new Command("closed loop control") {

      {
        requires(Arm.this);
      }

      boolean lowPower;


      @Override
      protected void initialize() {
        ControlMode mode = modeChooser.getSelected();
//        SlotConfiguration configuration = TalonSettings.PIDSlots.configurationForMode(mode);
//        int slot = TalonSettings.PIDSlots.slotForMode(mode);
//        talon.configureSlot(configuration, slot, 50);
        //TODO: this probably doesnt work anymore
        lowPowerMode.setBoolean(lowPower = false);
        lowPowerStartTime = System.currentTimeMillis();

      }

      @Override
      protected void execute() {

        double sp = ntSetpoint.getDouble(talon.getSelectedSensorPosition());

//        long elapsed = System.currentTimeMillis() - lowPowerStartTime;
//
//        if (Math.abs(talon.getErrorDerivative()) < 4.0
//                &&  elapsed > 500) {
//          if (!lowPower) {
//            System.out.println("low power @ " + elapsed
//                                   + " E=" + talon.getClosedLoopError()
//                                   + " dE=" + talon.getErrorDerivative());
//            lowPowerMode.setBoolean(lowPower = true);
//            talon.configVoltageCompSaturation(5.0);
//           // enableCurrentLimiting();
//          }
//        } else {
//          if (lowPower) {
//            System.out.println("full power @ " + elapsed
//                                   + " E=" + talon.getClosedLoopError()
//                                   + " dE=" + talon.getErrorDerivative());
//            lowPowerMode.setBoolean(lowPower = false);
//            talon.configVoltageCompSaturation(9.0);
//            // disableCurrentLimiting();
//          }
//        }
        talon.set(modeChooser.getSelected(), sp);
      }

      @Override
      protected void end() {
        disable();
        talon.configVoltageCompSaturation(9.0);
        enableCurrentLimiting();
      }

      @Override
      protected boolean isFinished() {
        return false;
      }
    });

    tab.add(new InstantCommand("Reset Encoder") {
      {
        requires(Arm.this);
      }

      @Override
      protected void execute() {
        talon.setSelectedSensorPosition(0);
        talon.getSensorCollection().setQuadraturePosition(0, 50);

      }

    });

    tab.add(new Command("Constant Output") {

      {
        requires(Arm.this);
      }

      @Override
      protected void execute() {
        talon.set(ControlMode.PercentOutput, percentOutput.getDouble(0.0));
      }

      protected void end() {
        disable();
      }

      @Override
      protected boolean isFinished() {
        return false;
      }
    });

  }

  @Override
  protected void onSetpointChange(double newSetpoint) {
    super.onSetpointChange(newSetpoint);
    talon.setIntegralAccumulator(0);
    disableCurrentLimiting();
    enableCurrentLimiting();
    lowPowerStartTime = System.currentTimeMillis();
  }


//      }

  @Override
  void configureTalon() {
    super.configureTalon();
    talon.configFactoryDefault();

    talon.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder);
    talon.selectProfileSlot(0, 0); //motion magic slot & primary pid


    talon.setInverted(true);
    talon.setSensorPhase(false);



    talon.configAllSettings(DEFAULT_CONFIG);

    talon.enableVoltageCompensation(true);
    talon.enableCurrentLimit(true);

    talon.configMotionSCurveStrength(8);

    /* Set relevant frame periods to be at least as fast as periodic rate */
    talon.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10);
    talon.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10);

  }

  @Override
  public void periodic() {
    super.periodic();
    talonTelemetry.run();
  }

}

